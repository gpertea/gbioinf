#!/usr/bin/perl
use strict;
use Getopt::Std;
use FindBin;use lib $FindBin::Bin;

my $usage = q/Usage:
 gffmanip [-v] [-o outrecords.txt] [-r<regata> [-R][-E]] [-t <track>] \
  [-f <feature1>[,..]] [-i [<attr>:]<tids.lst>] [-a <attr>=<value>[,..]] \
  [-k <attr1>[,..]] [-l <attr1>[,..]] [-m <IDchange.tab>] [-d <regdata>] \
  [-T] <gff\/gtf-input>

Filtering options:
 -S sort GFF records by location
 -C output only those transcripts having CDS features (protein Coding)
 -r show only transcripts overlapping any of the region intervals given in 
    <regdata> which has the format:
       [<strand>]<chr>[:<start>-<end>[,<start2>-<end2>,...]]
 -X for -r option, only print records whose exon\/CDS segments overlap the given
    interval(s) (i.e. intron-only overlaps are not considered)
 -R for -r option, only print transcripts fully contained in any of the given 
    range interval(s)
 -i only shows transcripts (or genes) whose IDs match any of the entries in the
    given file <ids.lst>; another attribute instead of ID can be used for 
    matching the list values if given as a <attr>: prefix to the file path
 -a only shows transcripts which have the <attr> attribute with the value 
    <value>; multiple attribute\/value pairs can be given (comma delimited)
    and a record is printed if there is at least one attribute match (OR list)
 -A for the -a option, when multiple <attr>=<value> conditions are given 
    (comma delimited), all of them have to be present and match (AND list)
 -v invert the filters (like grep's -v): print records that do NOT match any of
    the above transcript filtering options

 -f output only the specified GFF features, given as a comma-delimited
    list of strings (e.g. -f 'mRNA,exon,CDS') (doesn't work with -v)

Location modification options:
 -m replace contig\/chromosome IDs with different IDs, as specified in the given
    ID mapping table (a two column table mapping the old ID to the new ID)
    NOTE: renaming takes place when records are printed, *after* all the
    other filters have been applied
 -d contig\/chromosome region(s) deletion: discard the transcripts overlapping
    the given genomic region(s), shifting the coordinates of all the 
    features downstream from the deleted region(s)

Output options:
 -K keep all transcript\/gene attributes; by default only the core GFF
    attributes are shown (transcript_id, gene_id, gene_name, ID, Parent, Name)
 -k keep only the specified non-core GFF attributes in the output records
    (expects a comma delimited list of attribute names)
 -E keep all exon\/CDS GFF attributes
 -T print GTF format (default is GFF3)
 -l instead of GTF\/GFF, output a tab delimited table with transcript ID 
    in the first column and the value of all specified attribute(s) for each
    transcript in the other columns
 -t replace the string in the 2nd column with the given <track> text
 -V (verbose): show warnings or other potentially useful info
/;
umask 0002;
getopts('vCXERAKVTSo:f:t:i:a:k:l:m:d:') || die($usage."\n");
die("${usage}Error: no input file given (use '-' for stdin)\n") unless @ARGV>0;
shift(@ARGV) if ($ARGV[0] eq '-');
my $outfile=$Getopt::Std::opt_o;
my $verbose=$Getopt::Std::opt_V;
#my $delTinyIntrons=$Getopt::Std::opt_Z;
my $sort_gff=$Getopt::Std::opt_S;
my %ignoredFeatures;
@ignoredFeatures{qw(intron region contig scaffold)}=(); #let's ignore these useless features
my %oattrs; #hash with attrs to print
@oattrs{qw(ID transcript_id Parent gene_id gene geneID geneName gene_name)}=();
my %attrflt; # attribute=>value filter
my %idflt;   # hash with IDs to keep
my %atab;    # hash with attribute names whose values will be listed as tab delimited
my %chrmap; #if -m option was provided, maps chrID => new_chrID
my @atab_cols; 
if ($outfile) {
  open(OUTF, '>'.$outfile) || die("Error creating output file $outfile\n");
  select(OUTF);
}
# --
my ($fltinvert, $printGTF, $out_track)=
  ($Getopt::Std::opt_v, $Getopt::Std::opt_T, $Getopt::Std::opt_t);
my $only_ifCDS=$Getopt::Std::opt_C;
my ($idfile, $avflt, $featlist, $oattrlist)=
  ($Getopt::Std::opt_i, $Getopt::Std::opt_a, $Getopt::Std::opt_f, $Getopt::Std::opt_k);
die("Sorry, -v option does not work with -f !\n") if $fltinvert && $featlist;
my $keepAll=$Getopt::Std::opt_K || (lc($oattrlist) eq 'a' || lc($oattrlist) eq 'all');
my $keepExonAttrs=$Getopt::Std::opt_E;
my $avflt_all=$Getopt::Std::opt_A; #if $avflt should require a match for ALL given attributes
my ($check_range, $strict_ovl, $exon_ovl)=
   ($Getopt::Std::opt_r, $Getopt::Std::opt_R, $Getopt::Std::opt_X);
my $del_range=$Getopt::Std::opt_d;
my $chrmapping=$Getopt::Std::opt_m;
if (($del_range || $chrmapping) && $fltinvert) {
   die("Error: -v option cannot be used with -m or -d options!\n");
}
my ($flt_chr, $flt_strand);
my @flt_intv;
if ($check_range) {
  ($flt_chr, $flt_strand)=parseLocations($check_range, \@flt_intv);
}
#my $range=$flt_chr.':'.$ck_rex[0]->[0].'-'.$ex[-1]->[1];
my ($del_chr, $del_strand, $del_total);
my @del_intv;
if ($del_range) {
  ($del_chr, $del_strand)=parseLocations($del_range, \@del_intv);
  die("Error: invalid deletion location provided ($del_range)\n") if @del_intv==0;
  $del_total=0;
  foreach my $dseg (@del_intv) {
    $del_total+=$$dseg[1]-$$dseg[0]+1;
  }
}

$oattrlist='' if $keepAll;
my $tab_attrs=$Getopt::Std::opt_l;
if ($tab_attrs) {
  @atab_cols=split(/\,/, $tab_attrs);
  @atab{@atab_cols}=();
  }
my $idfileattr; # attribute to use for ID list filtering instead of ID/transcript_id
if ($idfile) {
  unless (-f $idfile) {
     my ($a,$f)=(split(/\:/,$idfile));
     ($idfile, $idfileattr)=($f,$a) if $f;
     }
  my $idf;
  #if ($idfile eq '-') {
  #  open($idf, "<&=STDIN") || die("Error: couldn't alias STDIN. $!\n");
  #} else {
    open($idf, $idfile) || die("Error: cannot open $idfile $!\n");
  #}
  while (<$idf>) {
    my ($id)=(m/(\S+)/);
    $idflt{$id}=1 if $id;
    }
  close($idf);
  }
if ($avflt) {
  my @avl=split(/\,/, $avflt); 
  foreach my $avpair (@avl) {
    my ($attr, $value)=split(/\s*=\s*/,$avpair,2);
    $value=~s/[" ]+$//;$value=~s/^[" ]+//;
    $attrflt{$attr}=$value;
    }
  }
my %featflt; # feature list filter -- if $featlist was given
if ($featlist)  {
 #add to the list of features to be kept
 my @fl=split(/\,/, $featlist);
 @featflt{@fl}=();
 }
if ($oattrlist) {
  #add to the list of attributes to be kept
  my @al=split(/\,/, $oattrlist);
  @oattrs{@al}=();
}

if ($chrmapping) {
 open(CMAP, $chrmapping) || die("Error: cannot open file $chrmapping \n");
 while (<CMAP>) {
   chomp;
   next if length($_)<2 || m/^#/;
   my @m=split(/[\s\,\=]+/);
   next if @m<2;
   $chrmap{$m[0]}=$m[1];
 }
 close(CMAP);
}

# ---- 
my %gffrecs; # recID =>  [ chr, strand, feat_type,  \%attrs, fstart, fend, [@exons], [@cds], track, subfeat, fscore ]
          #                0      1        2           3      4       5       6        7        8      9       10
          # recID has the prefix '<chr>|' which should be removed before output
#my $gffh;
#if ($input_gff eq '-') {
#  open($gffh, "<&=STDIN") || die("Error: couldn't alias STDIN $!\n");
#  }
#  else {
#  open($gffh, $input_gff) ||  die("Error opening file $input_gff $!\n");
#  }
my @gff_IDs; #IDs of each primary records (transcripts and genes) as they are encountered
loadGff(\%gffrecs);
if ($sort_gff) {
  my @sorted_recs=sort sortByLoc keys(%gffrecs);
  processGffRecs(\%gffrecs, \@sorted_recs);
}
else {
  processGffRecs(\%gffrecs, \@gff_IDs);
}

# --
if ($outfile) {
 select(STDOUT);
 close(OUTF);
 }

#************ Subroutines **************
sub sortByLoc {
 my $da=$gffrecs{$a};
 my $db=$gffrecs{$b};
 if ($$da[0] eq $$db[0]) {
    return ($$da[4]==$$db[4]) ? $$da[5] <=> $$db[5] : $$da[4] <=> $$db[4] ;
    }
  else { return $$da[0] cmp $$db[0] ; }
}
sub parseLocations {
  my ($s_range, $r_intv)=@_;
  my ($l_chr, $rlst)=split(/\:/,$s_range,2);
  #die("$usage Incorrect format for the interval list!\n") unless $l_chr && $rlst;
  my $l_strand=substr($l_chr,0,1);
  if ($l_strand eq '-' || $l_strand eq '+') {
     substr($l_chr,0,1)='';
  } else {
    $l_strand=undef; 
    my $e=substr($l_chr,-1);
    if ($e eq '-' || $e eq '+') {
        $l_strand=$e;
        chop($l_chr);
    }
    else { #try the suffix
      if ($rlst) {
        my $e=substr($rlst,-1);
        if ($e eq '-' || $e eq '+') {
           $l_strand=$e;
           chop($rlst);
        }
      }
    }
  } #no strand
  $l_strand='' if $l_strand eq '+';
  if ($rlst) {
    my @rdata=map { [split(/[\-\.]+/)] } (split(/[\,\;\s]+/,$rlst));
    foreach my $d (@rdata) {
      ($$d[0], $$d[1])=($$d[1], $$d[0]) if $$d[0]>$$d[1];
    }
    @$r_intv = sort { $a->[0] <=> $b->[0] } @rdata;
  }
  return ($l_chr, $l_strand);
}


sub checkOvlSegs { # $rx must be a ref to list of segments (intervals) SORTED
 my ($a, $b, $rx)=@_;
 return 0 if ($a>$$rx[-1]->[1] || $b<$$rx[0]->[0]); # not overlapping the whole list of segs
 foreach my $x (@$rx) {
   return 1 if ($a<=$$x[1] && $b>=$$x[0]);
   return 0 if $b<$$x[0];
   }
}

sub checkOvlDels {
 # $rseg is a reference to a tuple of coordinates [$a, $b]
 #       $rseg values will be updated according to the global @del_intv deletion data
 # $rx must be a ref to list of segments (intervals) SORTED
 my ($rseg, $rx)=@_; # return 1 if any overlap is found
 return 0 if ($$rseg[1]<$$rx[0]->[0]); # $rseg ends before any deletion
 my $del_acc=0;
 foreach my $x (@$rx) {
   return 1 if ($$rseg[0]<=$$x[1] && $$rseg[1]>=$$x[0]); #overlap with $x
   last if ($$rseg[1]<$$x[0]); #cannot overlap anymore
   $del_acc+=$$x[1]-$$x[0];
 }
 $$rseg[0]-=$del_acc;
 $$rseg[1]-=$del_acc;
 return 0;
}

sub checkWithinExons {
 my ($a, $b, $rx)=@_; #checks if interval $a-$b is contained in any @$rx interval
 return 0 if ($a>$$rx[-1]->[1] || $b<$$rx[0]->[0]); # not overlapping the whole exon chain
 foreach my $x (@$rx) {
   return 1 if ($a>=$$x[0] && $b<=$$x[1]);
   return 0 if $b<$$x[0];
 }
}


sub cleanupExons {
 my ($er, $rex, $cr, $rcd, $tid)=@_;
 @$rex=@$er;
 @$rcd=@$cr;
 if (@$rcd>0) {
   push(@$rex, @$rcd); #merge CDS segments, in case only UTRs were given
   @$rcd=sort { $a->[0] <=> $b->[0] } @$rcd;
 }
 @$rex=sort { $a->[0] <=> $b->[0] } @$rex;
 my $i=0;
 while ($i+1<@$rex) {
   # $$rev[$i] vs $$rex[$i+1]
   if ($$rex[$i+1]->[0]-$$rex[$i]->[1]<5) { #intron too small or overlapping exons!
       if ($verbose && $$rex[$i]->[4] eq $$rex[$i+1]->[4]) {
         print STDERR "Warning:merging overlapping or too close exons $$rex[$i]->[0]-$$rex[$i]->[1], ".
            "$$rex[$i+1]->[0]-$$rex[$i+1]->[1] of $tid\n";
       }
       $$rex[$i]->[1]=$$rex[$i+1]->[1] if $$rex[$i+1]->[1]>$$rex[$i]->[1];
       splice(@$rex, $i+1, 1);
   }
   else { ++$i }
 }
 $i=0;
 while ($i+1<@$rcd) {
   # $$rev[$i] vs $$rex[$i+1]
   if ($$rcd[$i+1]->[0]-$$rcd[$i]->[1]<2 &&
       ($$rcd[$i+1]->[4]=~m/codon/i  || $$rcd[$i]->[4]=~m/codon/i ) ) { 
       #adjacent or overlapping CDS with start/stop_codon feature
       $$rcd[$i]->[1]=$$rcd[$i+1]->[1] if $$rcd[$i+1]->[1]>$$rcd[$i]->[1];
       splice(@$rcd, $i+1, 1);
   }
   else { ++$i }
 }
}

#
sub rmTinyIntrons {
 my ($rex)=@_;
 my $i=0;
 while ($i+1<@$rex) {
   # $$rev[$i] vs $$rex[$i+1]
   if ($$rex[$i+1]->[0]-$$rex[$i]->[1]<4) { #intron too small or overlapping exons!
       $$rex[$i]->[1]=$$rex[$i+1]->[1] if $$rex[$i+1]->[1]>$$rex[$i]->[1];
       splice(@$rex, $i+1, 1);
   }
   else { ++$i }
 }
}


sub loadGff {
 my ($recs)=@_; #hash of record IDs to populate
 while (<>) {
   next if m/^\s*#/;
   chomp;
   my ($chr, $track, $f, $fstart, $fend, $fscore, $strand, $frame, $atr)=split(/\t/);
   my $line=$_;
   next unless $fstart>1 && $atr;
   my $reqfeat=exists($featflt{$f});
   next if $featlist && !$reqfeat;
   next if !$reqfeat && exists($ignoredFeatures{lc($f)});
   $track=$out_track if $out_track;
   my $xf;
   $xf='exon' if ($f=~m/exon/i || $f=~m/utr/i);
   $xf='CDS' if ($f=~m/^cds$/i || $f=~m/codon/i);
   my $exonFeature=($xf eq 'exon' || $xf eq 'CDS');
   #next if $f eq 'gene' || $f eq 'locus'; # Warning: skipping any 'gene' or 'locus' features, unconditionally
   my $gff3_ID;
   my $gff3_Parent;
   my %attrs;
   ($fstart, $fend)=($fend, $fstart) if $fend<$fstart;
   #$atr=~s/"([^"]+)\;([^"]+)"/"$1.$2"/g; #protect ; within text between quotes
   my $alstref=[];
   $attrs{'.'}=$alstref;
   my @av=split(/\s*\;\s*/, $atr);
   ($gff3_ID)=($atr=~m/\bID=([^;]+)/);
   ($gff3_Parent)=($atr=~m/\bParent=([^;]+)/);
   my $isGFF3 = ($gff3_ID || $gff3_Parent);
   if ($isGFF3) { # GFF format
      if ($gff3_ID && !$exonFeature) { #top level feature (e.g. gene, mRNA)
         foreach my $a (@av) {
            #keep attributes
            my ($attr, $value)=split(/\s*=\s*/,$a,2);
            $value=~s/[" ]+$//;$value=~s/^[" ]+//;
            push(@$alstref, $attr) unless $attr eq 'ID';
            $attrs{$attr}=$value;
         }
         #my $recID="$chr|$gff3_ID";
         my $recID=$gff3_ID;
         die("Error: duplicate feature $gff3_ID\n") if (exists($recs->{$recID}));
         push(@gff_IDs, $recID);
         $recs->{$recID} = [$chr, $strand, $f, {%attrs}, $fstart, $fend, [], [], $track, '', $fscore];
         next;
      } # parent/top-level feature
   }#GFF3
   else { #GTF
      if ($f eq 'transcript') { # GTF with parent 'transcript' feature
        foreach my $a (@av) {
           my ($attr, $value)=split(/\s+"/,$a,2); #"
           $value=~s/[" ]+$//;
           if ($attr eq 'transcript_id') {
              $attr='ID';
           } else {
             push(@$alstref, $attr);
           }
           $attrs{$attr}=$value;
        }
        my $recID=$attrs{'ID'};
        die("Error: cannot find transcript_id for GTF 'transcript' line:\n$line\n") unless $recID;
        die("Error: duplicate feature $recID\n") if (exists($recs->{$recID}));
        #$recID=$chr.'|'.$recID;
        $recs->{$recID} = [$chr, $strand, $f, {%attrs}, $fstart, $fend, [], [], $track, '', $fscore ];
        next;
      } # parent 'transcript' feature in GTF
   } #GTF
   # ---------- only exon/CDS features from here on ----
   next unless $exonFeature;
   my $recID;
   if ($isGFF3) {
      $recID=$gff3_Parent;
   }
   elsif ($atr=~m/transcript_id[= ]+(['"\:\w\.\|\-]+)/) {
     $recID=$1;
     $recID=~tr/"//d; #"
   }
   else {
     die("Error: cannot parse parent ID from input line:\n$line\n");
   }
   #$recID=$chr.'|'.$recID;
   my $ld = $recs->{$recID};
   if ($ld) { #existing entry
     my $i=($xf eq 'CDS') ? 7 : 6;
     my ($lstart, $lend)=($$ld[4], $$ld[5]);
     $$ld[4]=$fstart if $fstart<$lstart;
     $$ld[5]=$fend if $fend>$lend;
     my $exattrs='';
     if ($isGFF3 && $keepExonAttrs) {
       $exattrs=$atr;
       $exattrs=~s/\bParent=[^;]+;?//;
     }
     push(@{$$ld[$i]}, [$fstart, $fend, $fscore, $frame, $f, $exattrs]);
     #                       0      1       2       3     4   5
     #if ($xf ne 'CDS') {
     #   if ($$ld[9] && $$ld[9] ne $f) {
     #      die("Error: multiple non-CDS subfeatures found for $recID ($$ld[9], $f)\n");
     #   }
     #   $$ld[9]=$f;
     #}
   }
   else { # first time seeing this ID (shouldn't really happen for GFF3)
     # get the attributes from this first exon line, transfer to the parent
     if ($gff3_Parent) { #has GFF3 Parent - this should NOT happen usually
       print STDERR "Warning: exon feature found before/without parent $gff3_Parent!\n$line\n";
       foreach my $a (@av) {
           my ($attr, $value)=split(/\s*=\s*/,$a,2);
           $attr='ID' if $attr eq 'Parent';
           $value=~s/[" ]+$//;$value=~s/^[" ]+//;
       push(@$alstref, $attr) unless $attr eq 'ID';
       $attrs{$attr}=$value;
       }
     }
     else { # GTF input
       die("Error: found exon/CDS entry without parent!\n$line\n") if ($isGFF3);
       foreach my $a (@av) {
           my ($attr, $value)=split(/\s+"/,$a,2); #"
           $value=~s/[" ]+$//;
           if ($attr eq 'transcript_id') {
              $attr='ID';
           } else {
              push(@$alstref, $attr);
           }
           $attrs{$attr}=$value;
       }
     }
     $recs->{$recID} = ($f eq 'CDS') ? 
           [$chr, $strand, 'transcript', {%attrs}, $fstart, $fend,          [],      [[$fstart, $fend, $fscore, $frame, $f]], $track, '', '.' ] :
           [$chr, $strand, 'transcript', {%attrs}, $fstart, $fend, [[$fstart, $fend, $fscore, $frame, $f]], [],               $track, $f, '.' ] ;
         #   0       1      2     3        4       5       6(exons)                          7 (CDS)                           8       9   10
   }
 }
}

sub processGffRecs {
 #return if keys(%recs)==0;
 my ($recs, $rlist)=@_;
 my @recs_keys;
 unless ($rlist) {
   @recs_keys=keys(%$recs);
   $rlist=\@recs_keys;
 }
 my $lastchr; #to detect chr change
 my $dshift=0;
 foreach my $recid (@$rlist) {
   my $td=$$recs{$recid};
   #     0       1       2        3        4      5       6    7      8       9      10    
   my ($chr, $strand, $feature, $attrs, $fstart, $fend,  $er, $cr,  $track, $subf, $fscore) = @$td;
   my $newchr=($chr ne $lastchr);
   if ($newchr) {
      $dshift=0;
      $lastchr=$chr;
   }
   #next if ($rej && !$fltinvert);
   #next if ($fltinvert && $featlist && !$rej);
   # my ($mstart,$mend)=($fstart, $fend);
   my $CDSonly=0; # set to 1 if only CDS segments were given
   my $hasCDS=0;
   #some records might lack exons, but have only CDS segments (e.g. mitochondrial genes)
   if (@$er<1 && @$cr>0) { #no exon entries, but CDS
     #@ex = sort { $a->[0] <=> $b->[0] } @$cr;
     #@cds=@ex;
     $CDSonly=1;
     $hasCDS=1;
   } else { #exons declared
     #@ex = sort { $a->[0] <=> $b->[0] } @$er;
     if (@$cr>0) { # sort cds segments too
       #@cds= sort { $a->[0] <=> $b->[0] } @$cr;
       $hasCDS=1;
     }
   }
   my @ex; #refined exon segments (in case only UTRs are given, or non-CDS exon fragments)
   my @cds; #refined CDS segments (in case start/stop_codons are given)
   cleanupExons($er, \@ex, $cr, \@cds, $recid); #check for merging exon/UTR/CDS/start_codon/stop_codon into exon/CDS segments
   # --------------
   # get the more accurate version of the start-end coords for the feature
   my $covlen=0;
   # map { $covlen+=$_->[1]-$_->[0]+1 } @ex;
   my ($mstart, $mend) = ($ex[0]->[0], $ex[-1]->[1]);
   my $gffid=$recid;
   #substr($gffid, 0, length($chr)+1)='';
   die("Error: gffid ($gffid) not matching attrs\{ID\}(".$attrs->{'ID'}.")!\n")
       unless ($gffid eq $attrs->{'ID'});
   my $doprint=1;
   #check all the filters
   $doprint=0 if ($only_ifCDS && $hasCDS==0);
   if ($doprint && $idfile) {
     if ($idfileattr) {
        $doprint=0 unless exists($idflt{$attrs->{$idfileattr}});
        }
      else {
        $doprint=0 unless exists($idflt{$gffid});
        }
     }
    if ($doprint && $avflt) {
      my $avfound=0;
      if ($avflt_all) {
        #all attributes must be present and match
        $avfound=1;
        foreach my $a (keys(%attrflt)) {
          my $v=$attrs->{$a};
          if (!$v || $attrflt{$a} ne $v) {
            $avfound=0;
            last;
          }
        }
      } else {
        foreach my $a (keys(%attrflt)) {
          if ($attrflt{$a} eq $attrs->{$a}) {
            $avfound=1;
            last;
          }
        }
      }
      $doprint=0 if !$avfound;
    }
  if ($doprint && $flt_chr && $flt_chr ne $chr) {
    $doprint=0;
  }
  if ($doprint) {
    if ($flt_strand && $flt_strand ne $strand) {
      $doprint=0;
    }
  }
  if ($doprint && @flt_intv>0) {
    if ($exon_ovl) { #t span overlap any range intervals
       for my $ed (@ex) {
         if (checkOvlSegs($$ed[0], $$ed[1], \@flt_intv)) {
            $doprint=1;
            last;
            }
         }
    } elsif ($strict_ovl) {
       $doprint=1 if checkOvlWithin($fstart, $fend, \@flt_intv);
    } else {
      $doprint=1 if checkOvlSegs($fstart, $fend, \@flt_intv);
    }
  }
  $doprint = ! $doprint if $fltinvert;
  next unless $doprint;
  # check for chr sequence deletion
  if ($del_chr && $del_chr eq $chr) {
     my $exovl; #set if exon overlap detected
     for my $ed (@ex) {
        $exovl=checkOvlDels($ed, \@del_intv); 
        last if $exovl;
     }
     next if $exovl;
  }
  #filter passed, print output
  #if ($delTinyIntrons) {
  #  rmTinyIntrons(\@ex) if @ex>1;
  #  #-- do NOT do it for CDS - because of "ribosomal slippage exception" (programmed frameshift)
  #  #rmTinyIntrons(\@cds) if @cds>1;
  #}
  if ($tab_attrs) {
     my @od;
     foreach my $a (@atab_cols) {
       if (uc($a) eq 'ID') {
          push(@od, $gffid);
          next;
          }
       push(@od, $attrs->{$a});
       }
     print join("\t",@od)."\n";
     next;
  }
  #the core attributes ID, Name must be there already
  #   unless (exists($attrs->{Name})) {
  #      foreach my $name (qw(gene_name gene geneID geneId geneid locus loc ID)) {
  #        if (exists($attrs->{$name})) {
  #            $attrs->{Name}=$attrs->{$name};
  #            last;
  #            }
  #           }
  #   }
  #my ($tid, $tname)= (delete($attrs->{'ID'}), delete($attrs->{'Name'}));
  #   unless ($keepAll) {
  #      if (exists($attrs->{'gene_name'})) {
  #           $gene_name=delete($attrs->{'gene_name'});
  #           $gene_name=undef if ($gene_name eq $tname && !exists($oattrs{'gene_name'}));
  #      }
  #      if (exists($attrs->{'gene'})) {
  #           $gene=delete($attrs->{'gene'});
  #           $gene=undef if ($gene eq $tname || $gene eq $gene_name) && !exists($oattrs{'gene'});
  #      }
  #      if (exists($attrs->{'locus'})) {
  #           $locus=delete($attrs->{'locus'});
  #           $locus=undef if ($locus eq $gene_name || $locus eq $gene_name) && !exists($oattrs{'locus'});
  #      }
  #   }
  
  #chromosome mapping (renaming) requested?
  if ($chrmapping) {
    my $cnew=$chrmap{$chr};
    $chr=$cnew if ($cnew);
  }
  
  my $tid=delete($attrs->{'ID'});
  my $tattrs;
  if ($printGTF) { #print GTF
     my $gene_id; #for GTF printing
     $gene_id=delete($attrs->{'gene_id'});
     if (!$gene_id) {
       my @gattrs=grep { /^gene_?id/i } @{$attrs->{'.'}};
       $gene_id=delete($attrs->{$gattrs[0]}) if @gattrs>0
     }
     if (!$gene_id) {
       my @gattrs=grep { /^gene$/i } @{$attrs->{'.'}};
       @gattrs=grep { /^gene/i } @{$attrs->{'.'}} if (@gattrs==0);
       $gene_id=delete($attrs->{$gattrs[0]}) if @gattrs>0
     }
     $tattrs='transcript_id "'.$tid.'";';
     $tattrs.=' gene_id "'.$gene_id.'";' if $gene_id;
     if ($keepAll) {
        foreach my $attr (@{$attrs->{'.'}}) {
           my $val=$attrs->{$attr};
           $tattrs.=' '.$attr.' "'.$val.'";' if $val;
        }
     }
     else { # only a subset of attributes will be shown
        foreach my $attr (@{$attrs->{'.'}}) {
           next unless exists($oattrs{$attr});
           my $val=$attrs->{$attr};
           $tattrs.=' '.$attr.' "'.$val.'";' if $val;
        }
     }
    print join("\t",$chr, $track, 'transcript', $fstart, $fend, $fscore, $strand, '.', $tattrs)."\n";
  } else { #print GFF3
     my $pattrs="ID=$tid";
     #$pattrs.='gene_name='.$gene_name.';' if $gene_name;
     #$pattrs.='gene='.$gene.';' if $gene;
     #$pattrs.='locus='.$locus.';' if $locus;
     if ($keepAll) {
        foreach my $attr (@{$attrs->{'.'}}) {
           my $val=$attrs->{$attr};
           $pattrs.=";$attr=$val" if $val;
           }
     }
     else { # only a subset of attributes will be shown
        foreach my $attr (@{$attrs->{'.'}}) {
           next unless exists($oattrs{$attr});
           my $val=$attrs->{$attr};
           $pattrs.=";$attr=$val" if $val;
        }
     }
     print join("\t",$chr, $track, $feature, $fstart, $fend, $fscore, $strand, '.', $pattrs)."\n";
     $tattrs='Parent='.$tid;
  }
  if ($CDSonly==0) { #write exons only when found in the input
        foreach my $ed (@ex) {
            my $xattrs=$tattrs;
            $xattrs.=';'.$$ed[5] if $$ed[5];
            print join("\t",$chr, $track, 'exon', $$ed[0], $$ed[1], $$ed[2], $strand, $$ed[3], $xattrs)."\n";
        }
  }
  foreach my $cd (@cds) {
        my $xattrs=$tattrs;
        $xattrs.=';'.$$cd[5] if $$cd[5];
        print join("\t",$chr, $track, 'CDS', $$cd[0], $$cd[1], $$cd[2], $strand, $$cd[3], $xattrs)."\n";
  }
 } #for each stored transcript
}

